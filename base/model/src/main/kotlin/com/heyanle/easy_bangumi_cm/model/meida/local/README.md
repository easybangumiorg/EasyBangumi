
# 关于本地库的扫描，刮削与挂载

> [!IMPORTANT]
> 在开发完视频类的项目扫描器后，才可以考虑开发音乐、电子书等资源的扫描器
> 开发时应当为后续的扩展留下空间，如在项目扫描器中应当考虑到子项目的扫描

> [!WARNING]
> 早期开发阶段，可能会翻译很多相关实现的代码，在之后会逐渐优化

## 假设

1. 根目录内每一个文件夹都是一个项目
2. 项目文件夹的名称一定包含这一项目的关键字，如‘葬送的芙莉莲’、‘你想活出怎样的人生’、‘鬼灭之刃 第X季 XXX篇’
3. 由项目文件夹内资源的类型确定项目所属的类型，这个类型是可叠加的，如’葬送的芙莉莲‘既可以包括系列电视节目，也可以包括电子书，甚至是音乐专辑
4. 项目内的子项目一定是与父项目有关的，如‘葬送的芙莉莲’的子项目可能是‘葬送的芙莉莲 OVA’、‘葬送的芙莉莲 第二季’
5. 同一个IP的不同资源可以分布在多个项目内（这个待定，会增加部分解析器工作量）

一个典型的项目结构如下：

XXXX
- XXXX 大电影.mkv
- XXXX 第一季
- - subtitles
- - - XXXX S1:E1.srt
- - - XXXX S1:E2.srt
- - XXXX S1:E1.mp4
- - XXXX S1:E2.mp4
- XXXX Season 2
- - XXXX S2:E1.mp4
- - XXXX S2:E1.srt
- - XXXX S2:E2.mp4
- - XXXX S2:E2.srt
- XXXX OST
- - XXXX OST 1.mp3
- - XXXX OST 2.wav
- XXXX Books
- - XXXX Book 1.pdf
- - XXXX Book 2.mobi
- - XXXX Book 3.epub

另一个常见的项目结构如下：

XXXX
- []XXXX - 1[][][].mp4
- []XXXX - 2[][][].mp4
- []XXXX - 3[][][].mp4

## 要求

1. 在根目录创建.manifest文件夹，记录整个库的快照，用于记录库的变更
2. 美术图资源，存于项目或是子项目的文件夹内
3. 元数据以MediaBrowser兼容的nfo文件存储（这个也待定，需要更上层的开发支持）
4. 本地扫描器仅提供对本地项目文件类型的抽象，返回树形的虚拟项目结构，再由上层根据项目的刮削结果进行同类项合并
5. 单独的电影文件为其额外创建MeidaNode（作废）

```text
Root > [
    Project > SubProject > Resource
    Project > Resource
]
```

## 本地库扫描步骤

1. 提供根目录，库配置
2. DFS遍历库存目录，获取文件系统树 FileSystemNode
3. 核心是获取媒体节点树

我趣Jellyfin这栈怎么到处飞的，我倒要看看他们怎么做的 ，当然最后呈现的效果应该同网易爆米花.


针对设计媒体库检索器的需求，以下是分步解决方案思路：

### 1. 节点树遍历策略
- **深度优先遍历**：从根目录开始递归处理每个节点（文件/目录），确保所有子节点被访问。
- **上下文继承**：遍历时维护上下文栈，保存当前路径累积的元信息（如剧名、年份、季数），子节点继承并允许覆盖。

### 2. 解析器设计
- **分层解析规则**：
    - **目录节点**：提取可能包含的元信息（如剧名、年份、季数），例如：
        - 匹配 `(剧名) (年份)` 模式（如 `Friends (1994)`）。
        - 识别 `Season XX` 或 `SXX` 作为季数。
    - **文件节点**：提取更具体的元信息（如集数、媒体类型），例如：
        - 使用正则表达式匹配 `S01E02`、`01x02` 或 `Episode 02` 等格式。
        - 检测文件扩展名（`.mkv`, `.mp4`）以确定媒体类型。
- **多模式匹配**：定义优先级规则（如文件名优先于目录名），使用正则表达式库支持多种命名习惯。

### 3. 元信息聚合与合并
- **数据结构**：采用嵌套字典或对象模型组织数据：
  ```python
  {
    "type": "tv_show",
    "title": "Friends",
    "year": 1994,
    "seasons": {
      1: {
        "episodes": {
          1: {"path": "/path/S01E01.mp4"},
          2: {"path": "/path/S01E02.mp4"}
        }
      }
    }
  }
  ```
- **合并逻辑**：根据剧名、年份、季数等关键字段合并同一媒体项，确保同一季的剧集归入对应位置。

### 4. 变更检测机制
- **状态快照**：保存上次扫描结果的哈希表（以唯一标识符如`剧名-年份-季-集`为键）。
- **差异比对**：
    - **新增**：当前存在但旧快照中无的记录。
    - **删除**：旧快照存在但当前缺失的记录。
    - **修改**：路径或元信息变化的记录（通过比较哈希值或时间戳）。

### 5. 处理复杂结构
- **灵活路径处理**：
    - 忽略无关中间目录（如 `Extras`、`Bonus`）。
    - 支持多季分散在不同目录（如 `Season 1` 和 `S02` 目录并存）。
- **动态上下文更新**：根据目录名动态调整解析策略（如进入 `Season 2` 目录后，后续文件默认继承季数）。

### 6. 参考方案优化点
- **正则表达式库**：预置常见匹配模式（参考Plex命名规范），如：
    - 剧集：`/(?<title>.*) S(?<season>\d{2})E(?<episode>\d{2})/i`
    - 电影：`/(?<title>.*) \((?<year>\d{4})\)/i`
- **用户自定义规则**：允许用户扩展正则规则或调整优先级，适应个性化命名。

### 7. 异常处理与日志
- **冲突解决**：同名不同年份的媒体项视为独立条目。
- **日志记录**：记录无法解析的文件路径，供后续分析调整规则。

### 示例解析流程
路径：`/Media/TV Shows/Game of Thrones (2011)/Season 3/GOT S03E04.mp4`

1. **遍历目录**：
    - 解析 `Game of Thrones (2011)` → 剧名=Game of Thrones，年份=2011。
    - 进入 `Season 3` → 季数=3。
    - 解析文件 `GOT S03E04.mp4` → 季=3（与目录一致），集=4。

2. **聚合结果**：
    - 归入 `Game of Thrones` 的2011年条目下，第3季第4集。

### 总结
通过分层解析、上下文继承和灵活的模式匹配，结合结构化的数据聚合与差异对比，可有效提取并管理复杂目录中的媒体元信息。此方案平衡了自动化解析与可扩展性，适用于多数常见媒体库结构。